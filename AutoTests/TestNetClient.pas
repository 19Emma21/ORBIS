unit TestNetClient;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework,
  App.IHandlerCore,
  System.Generics.Collections,
  Net.Client,
  System.SysUtils,
  System.Threading,
  System.Types,
  System.Net.Socket,
  System.RTTI,
  System.Math,
//  Net.Server,
  App.HandlerCore,
  App.Config,
  System.Classes;

type
  // Test methods for class TClient

  TestTClient = class(TTestCase)
  strict private
    FClient: TClient;
    FHandler : THandlerCore;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestTryConnect;
    procedure TestDisconnect;
    procedure TestTryDisconnect;
    procedure TestConnected;
    procedure TestCallBack;
    procedure TestStartReceive;
    procedure TestSendMessage;
    procedure TestInit;
  end;

implementation

procedure TestTClient.SetUp;
var
  FConfig : TConfig;
begin
  FHandler := THandlerCore.Create;
  FConfig := TConfig.Create;
  if not FConfig.DoConfigurate then
    Fail('Bad Config');
  FClient := TClient.Create(FHandler);
end;

procedure TestTClient.TearDown;
var
  FValue: TValue;
  FSSocket : TSocket;
begin
  //Value
  FSSocket:= TSocket.Create(TSocketType.TCP);
  FValue:= TRttiContext.Create.GetType(TClient).GetField('Socket').GetValue(FClient);
  FValue.TryAsType(FSsocket);
  //Begin
  if FSSocket <> nil then
  begin
    if TSocketState.Connected in FSSocket.State then
      FClient.Free;
  end;
  // Nil
  FClient := nil;
  FSSocket:= nil;
  FValue:= nil;
end;

procedure TestTClient.TestTryConnect;
var
  ReturnValue: Boolean;
  APort: Word;
  AIP: string;
  FListPort: TList<integer>;
  FRegistered, FCounter : integer;
begin
  //Value
  AIP:= '127.0.0.1';
  APort:= 30000;
  FRegistered:= 1023;
  FListPort:= TList<integer>.Create;
  for FCounter := 0 to FRegistered - 1 do
    FListPort.Add(FCounter);
  try
  //Conditions
    for FCounter := 0 to FListPort.Count - 1 do
      CheckNotEquals(FListPort[FCounter],APort,'This port is already in use by another program');
  //Begin
    ReturnValue := FClient.TryConnect(AIP, APort);
  //Conditions
  CheckTrue(ReturnValue,'Connection failed');
  except
  on E : Exception do
    Fail('TryConnect returned error ' + e.Message);
  end;
  //Finally
  FClient.Disconnect;
  Status('TryConnect success');
end;

procedure TestTClient.TestDisconnect;
var
  FSocket : TSocket;
  FValue : TValue;
begin
  try
  //Begin
    FClient.TryConnect('127.0.0.1', 30000);
    FValue:= TRttiContext.Create.GetType(TClient).GetField('Socket').GetValue(FClient);
    FValue.TryAsType(FSocket);
    if not (TSocketState.Connected in FSocket.State) then
      fail('Socket already close');
    FClient.Disconnect;
  except
  on E : Exception do
    Fail('Disconnect returned error ' + e.Message);
  end;
end;

procedure TestTClient.TestInit;
var
  FRttiMethod : TRttiMethod;
  FValue : TValue;
  FClientSocket : TSocket;
  FDataSize : Integer;
  FData : TBytes;
begin
  try
  //Begin
    FRttiMethod:= TRttiContext.Create.GetType(TClient).GetMethod('Init');
    FRttiMethod.Invoke(FClient, []);
  //Conditions
    FValue:= TRttiContext.Create.GetType(TClient).GetField('Socket').GetValue(FClient);
    FValue.TryAsType(FClientSocket);
    if not Assigned(FClientSocket) then
      Fail('Socket didnt created');
    FValue:= TRttiContext.Create.GetType(TClient).GetField('DataSize').GetValue(FClient);
    FDataSize:= FValue.AsInteger;
    if FDataSize <> 0 then
      Fail('DateSize initialization error');
    FValue:= TRttiContext.Create.GetType(TClient).GetField('Data').GetValue(FClient);
    FValue.TryAsType(FData);
    if FData <> nil then
      Fail('Date initialization error');
  except
  On E : Exception do
    Fail('Init returned error ' + e.Message);
  end;
end;

procedure TestTClient.TestTryDisconnect;
var
  ReturnValue: Boolean;
  FValue : TValue;
  FConnectedSocket : TSocket;
begin
  try
  //Begin
    FClient.TryConnect('127.0.0.1', 30000);
    ReturnValue := FClient.TryDisconnect;
  //Conditions
    CheckTrue(ReturnValue,'Disconnect didnt not occur');
    FValue := TRttiContext.Create.GetType(TClient).GetField('Socket').GetValue(FClient);
    FValue.TryAsType(FConnectedSocket);
    if TSocketState.Connected in FConnectedSocket.State then
      Fail('Socket is still open');
  except
  on E : Exception do
    Fail('TryDisconnect returned error ' + e.Message);
  end;
end;

procedure TestTClient.TestConnected;
var
  ReturnValue: Boolean;
begin
  //Begin
  try
    FClient.TryConnect('127.0.0.1',30000);
    ReturnValue := FClient.Connected;
  //Conditions
    CheckTrue(ReturnValue,'Coonected didnt work');
  except
  on E : Exception do
    Fail('Connected returned error ' + E.Message);
  end;
  FClient.Disconnect;
end;

procedure TestTClient.TestCallBack; //Rework
var
  ASyncResult: IAsyncResult;
  FClientSocket : TSocket;
begin
  try
  //Value
    FClientSocket := TSocket.Create(TSocketType.TCP);
    FClientSocket.Connect('','127.0.0.1','', 30000);
    ASyncResult:= FClientSocket.BeginReceive();
  //Begin
    FClient.CallBack(ASyncResult); //Waiting to receive bytes from Hercules
    FClient.TryDisconnect;
    FClientSocket.Close(true);
    FClientSocket.Free;
    ASyncResult:= nil;
  except
  on E : Exception do
    Fail('CallBack returned error ' + e.Message);
  end;
end;

procedure TestTClient.TestStartReceive;
var
  FValue : TValue;
  FSocketNotNill : TSocket;
begin
  try
  //Begin
    FValue := TRttiContext.Create.GetType(TClient).GetField('Socket').GetValue(FClient);
    FValue.TryAsType(FSocketNotNill);
    if FSocketNotNill <> nil then
      FClient.StartReceive
    else
      Fail('Socket is nil');
  except
  on E : Exception do
    Fail('StartReceive returned error' + e.Message);
  end;
end;

procedure TestTClient.TestSendMessage;
var
  FData, FBuf: TBytes;
  FMinLenghtData, FMaxLenghtData, FTotalSize, FLenght : integer;
  FValue : TValue;
  FConnectedSocket : TSocket;
  FTotal : integer;
begin
//Value
  FData:= [4,3,0,0,0,0,0,0,0];
  FMaxLenghtData:= 65000;
  FMinLenghtData := 9;
  FValue := TRttiContext.Create.GetType(TClient).GetField('Socket').GetValue(FClient);
  FValue.TryAsType(FConnectedSocket);
  try
//Conditions
    if not Assigned(FConnectedSocket) then
      Fail('Socket is nil');
    if not (TSocketState.Connected in FConnectedSocket.State) then
      Fail('Socket not connected');
    if not Assigned(FData) then
      Fail('Network package is nil');
    FLenght:= Length(FData);
    setLength(Fbuf, SizeOf(integer));
    Move(FLenght, Fbuf[0], SizeOf(integer));
    FTotalSize := FBuf[0] + FBuf[1] + FBuf[2] + FBuf[3];
    CheckEquals(FLenght, FTotalSize, 'Network package created incorrectly');
    if (FLenght >= FMaxLenghtData) or (FLenght < FMinLenghtData) then
      Fail('Incorrectly Length package');
    if (FData[0] > 14) then
      Fail('Incorrectly packet');
//Begin
    FClient.SendMessage(FData);
  except
  on E: Exception do
    Fail('SendMessage returned error ' + e.Message);
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTClient.Suite);
end.

