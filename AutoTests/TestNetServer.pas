unit TestNetServer;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework,
  Net.Server,
  Net.ConnectedClient,
  System.SyncObjs,
  System.Generics.Collections,
  System.SysUtils,
  System.Threading,
  System.Types,
  System.Net.Socket,
  System.RTTI,
  Net.Core,
  App.HandlerCore,
  App.Config,
  System.Classes;

type
  // Test methods for class TServer
  TestTServer = class(TTestCase)
  strict private
    FServer: TServer;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestStart;
    procedure TestStop;
    procedure TestDoWaitStopServer;
    procedure AcceptCallBack;
  end;

implementation

procedure TestTServer.AcceptCallBack;
var
  FNetCore : TNetCore;
  FHandler : THandlerCore;
  FConfig : TConfig;
  FNodeHost : TArray<string>;
  FApprovedIp : TArray<string>;
  FRttiMEthod : TRttiMethod;
  FBanned : boolean;
  FIp : String;
  FMaxConnectedClient, FCounter : Integer;
begin
  try
  //Value
    FConfig := TConfig.Create;
    if not FConfig.DoConfigurate then
      Fail('Bad Config');
    FNodeHost := ['127.0.0.1'];
    FApprovedIp := ['127.0.0.1','192.168.0.2','192.168.1.25','192.168.66.6','10.10.10.57','10.158.69.42'];
    FHandler := THandlerCore.Create;
    FNetCore := TNetCore.Create(FHandler,FNodeHost,FApprovedIp);
    FMaxConnectedClient:= 2000000000;
  //Begin
    SetLength(FNetCore.ConnectedClients, 2);
    if Length(FNetCore.ConnectedClients) >= FMaxConnectedClient then
      Fail('Maximum number of clients has been exceeded');
    FNetCore.Start;
  //Conditions
    CheckTrue(FNetCore.ServerStarted, 'Server not started');
    if not Assigned(FNetCore.ConnectedClients) then
      Fail('No connected clients');
    for FCounter := 0 to Length(FNetCore.ConnectedClients) - 1 do
      begin
        if not Assigned(FNetCore.ConnectedClients[FCounter]) then
          break;
        FIp:= FNetCore.ConnectedClients[FCounter].SocketIP;
        FRttiMEthod := TRttiContext.Create.GetType(TNetCore).GetMethod('Checks');
        FBanned:= FRttiMEthod.Invoke(FNetCore, [FIp]).AsBoolean;
        CheckTrue(FBanned, 'IP in Banlist');
      end;
    FNetCore.Stop;
    FNetCore.Free;
  except
  on E : Exception do
    begin
      FNetCore.Stop;
      FNetCore.Free;
      Fail('AcceptCallBack returned error ' + e.Message);
    end;
  end;
end;

procedure TestTServer.SetUp;
begin
  FServer := TServer.Create();
end;

procedure TestTServer.TearDown;
begin
  FServer.Free;
  FServer := nil;
end;

procedure TestTServer.TestDoWaitStopServer; //Rework
var
  FRttiMethod : TRttiMethod;
  FServerStatus : Boolean;
begin
  try
//Begin
    FRttiMethod:= TRttiContext.Create.GetType(TServer).GetMethod('DoWaitStopServer');
    FRttiMethod.Invoke(FServer,[]);
//Conditions
    FServerStatus:= FServer.isActive;
    CheckFalse(FServerStatus,'Server is not stoped');
  except
  on E : Exception do
    Fail('DoWaitStopServer returned error ' + e.Message);
  end;
end;

procedure TestTServer.TestStart;
var
  APort, FRegistered: Word;
  AIP: string;
  FListPort : TList<integer>;
  FCounter : Integer;
  FActiveStatus : boolean;
  FValue : TValue;
  FListenSocket : TSocket;
  FListenState : TSocketState;
begin
  //Value
  AIP:= '127.0.0.1';
  APort := 30000;
  FListenState := TSocketState.Listening;
  FRegistered:= 1023;
  FListPort:= TList<integer>.Create;
  for FCounter := 0 to FRegistered - 1 do
    FListPort.Add(FCounter);
  try
  //Conditions
    FActiveStatus := FServer.isActive;
    CheckFalse(FActiveStatus,'Server already started');
    for FCounter := 0 to FListPort.Count - 1 do
      CheckNotEquals(FListPort[FCounter],APort,'This port is already in use by another program');
  //Begin
    FServer.Start(AIP, APort);
  //Conditions
    FActiveStatus := FServer.isActive;
    CheckTrue(FActiveStatus,'Server not started');
    FValue := TRttiContext.Create.GetType(TServer).GetField('Socket').GetValue(FServer);
    FValue.TryAsType(FListenSocket);
    if not (FListenState in FListenSocket.State) then
      Fail('Socket not listening');
  except
  on E : Exception do
    Fail('Start returned error ' + e.Message);
  end;
  FServer.Stop;
end;

procedure TestTServer.TestStop;
var
  FActiveStatus : boolean;
  FValue : TValue;
  FConnectedSocket : TSocket;
  FArrayState : TSocketStates;
begin
  //Value
  FServer.Start('127.0.0.1', 30000);
  FArrayState := [TSocketState.Connected, TSocketState.Client, TSocketState.Listening];
  FActiveStatus:= FServer.isActive;
  FValue := TRttiContext.Create.GetType(TServer).GetField('Socket').GetValue(FServer);
  FValue.TryAsType(FConnectedSocket);
  try
  //Conditions
    CheckTrue(FActiveStatus,'Server already stop');
    if not Assigned(FConnectedSocket) then
      Fail('Socket is nil');
  //Begin
    FServer.Stop;
  //Conditions
    FActiveStatus:= FServer.isActive;
    CheckFalse(FActiveStatus,'Server did not stop');
    FValue := TRttiContext.Create.GetType(TServer).GetField('Socket').GetValue(FServer);
    FValue.TryAsType(FConnectedSocket);
    if FConnectedSocket.State = FArrayState then
      Fail('Socket didnt closed');
  except
  on E: Exception do
    Fail('Stop returned error ' + e.Message);
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTServer.Suite);
end.

