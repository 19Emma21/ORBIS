unit TestNetConnectedClient;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework,
  Net.ConnectedClient,
  System.Generics.Collections,
  System.SysUtils,
  System.Threading,
  System.Types,
  System.Net.Socket,
  Net.Core,
  UI.Abstractions,
  App.IHandlerCore,
  App.HandlerCore,
  System.RTTI,
  BlockChain.Core,
  App.Config,
  App.Paths,
  App.Types,
  System.Classes;

type
  // Test methods for class TConnectedClient

  TestTConnectedClient = class(TTestCase)
  strict private
    FNodeHost : TArray<string>;
    FApprovedIp : TArray<string>;
    FSocket : TSocket;
    FConnectedClient: TConnectedClient;
    FNetCore : TNetCore;
    FHandler : THandlerCore;
    FConfig : TConfig;
  private
    procedure TestReference(AId : integer; AState : integer);
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestDoApprove;
    procedure TestDoNotApprove;
    procedure TestDisconnect;
    procedure TestCallBack;
    procedure TestStartReceive;
    procedure TestSendMessage;
    procedure TestGetSocketIp;
    procedure TestIsActive;
  end;

implementation

procedure TestTConnectedClient.SetUp;
begin
  FConfig := TConfig.Create;
  if not FConfig.DoConfigurate then
    Fail('Bad Config');
  FNodeHost := ['127.0.0.1'];
  FApprovedIp := ['127.0.0.1','192.168.0.2','192.168.1.25','192.168.66.6','10.10.10.57','10.158.69.42'];
  FHandler := THandlerCore.Create;
  FNetCore:= TNetCore.Create(FHandler,FNodeHost,FApprovedIp);
  FSocket:= TSocket.Create(TSocketType.TCP);
  FSocket.Connect('', '127.0.0.1', '', 30000);
  FConnectedClient := TConnectedClient.Create(FSocket);
  FConnectedClient.AfterDisconnect := TestReference;
end;

procedure TestTConnectedClient.TearDown;
begin
  FNetCore.Free;
  FNetCore := nil;
end;

procedure TestTConnectedClient.TestDoApprove;
var
  FReturnValue : Boolean;
  FV: TValue;
begin
  //Value
    FV:= TRttiContext.Create.GetType(TConnectedClient).GetField('Approved').GetValue(FConnectedClient);
    FReturnValue:= FV.AsBoolean;
  try
  //Begin
    CheckFalse(FReturnValue,'Approved already true');
    FConnectedClient.DoApprove;
    FV:= TRttiContext.Create.GetType(TConnectedClient).GetField('Approved').GetValue(FConnectedClient);
    FReturnValue:= FV.AsBoolean;
  //Conditions
    CheckTrue(FReturnValue,'DoApprove didnt work ');
  except
  on E : Exception do
    Fail('DoApprove returned error ' + e.Message);
  end;
end;

procedure TestTConnectedClient.TestDoNotApprove;
var
  FValue : TValue;
  FApproveSocket : TSocket;
  FDataConClient : TBytes;
begin
  try
  //Value
    FValue := TRttiContext.Create.GetType(TConnectedClient).GetField('Socket').GetValue(FConnectedClient);
    FValue.TryAsType(FApproveSocket);
  //Begin
    if not Assigned(FApproveSocket) then
      Fail('Socket is nil ');
    FConnectedClient.DoNotApprove;
  //Ñonditions
    FValue := TRttiContext.Create.GetType(TConnectedClient).GetField('Socket').GetValue(FConnectedClient);
    FValue.TryAsType(FApproveSocket);
    CheckNull(FApproveSocket , 'DoNotApprove doesnt work');
    FValue:= TRttiContext.Create.GetType(TConnectedClient).GetField('Data').GetValue(FConnectedClient);
    FValue.TryAsType(FDataConClient);
    if FDataConClient <> nil then
      Fail('DoNotApprove doesnt work');
  except
  on E : Exception do
    Fail('DoNotApprove returned error ' + e.Message);
  end;
end;

procedure TestTConnectedClient.TestGetSocketIp;
var
  FZeroValue, FReturnValue, FEmptyLine: string;
  FValue : TValue;
  FBanList : TThreadList<string>;
begin
  //Value
  FZeroValue := '0.0.0.0';
  FEmptyLine:= '';
  FValue:= TRttiContext.Create.GetType(TNetCore).GetField('BanList').GetValue(FNetCore);
  FValue.TryAsType(FBanList);
  try
  //Begin
    FReturnValue:= FConnectedClient.GetSocketIP;
  //Ñonditions
    CheckNotEquals(FZeroValue,FReturnValue,'GetSocketIP Returned - 0.0.0.0; ');
    CheckNotEquals(FEmptyLine,FReturnValue,'GetSocketIP Returned - empty line; ');
    if not (FBanList.LockList.IndexOf(FReturnValue) = -1) then
      Fail('IP Address is in Ban List');
    FBanList.UnlockList;
  except
  on E : Exception do
    Fail('GetSocketIP Returned Error: ' + E.Message);
  end;
end;

procedure TestTConnectedClient.TestIsActive;
var
  FRttiMethod : TRttiMethod;
  FStatus : boolean;
begin
  try
    FRttiMethod := TRttiContext.Create.GetType(TConnectedClient).GetMethod('isActive');
    FStatus := FRttiMethod.Invoke(FConnectedClient, []).AsBoolean;
    CheckTrue(FStatus, 'Status is not Active');
  except
  on E : Exception do
    Fail('IsActive returned error ' + e.Message);
  end;
end;

procedure TestTConnectedClient.TestReference(AId, AState: integer);
begin
//ForTest
end;

procedure TestTConnectedClient.TestDisconnect;
var
  FConnect : TSocketState;
  FRttiMethod : TRttiMethod;
  FStatus : Boolean;
  FSocketConnected : TSocket;
  FValue : TValue;
begin
  //Value
  FConnect:= TSocketState.Connected;
  FRttiMethod := TRttiContext.Create.GetType(TConnectedClient).GetMethod('isActive');
  FStatus := FRttiMethod.Invoke(FConnectedClient, []).AsBoolean;
  try
  //Ñonditions
    CheckTrue(FStatus, 'Status is not Active');
  //Begin
    FConnectedClient.Disconnect;
  //Ñonditions
    FValue := TRttiContext.Create.GetType(TConnectedClient).GetField('Socket').GetValue(FConnectedClient);
    FValue.TryAsType(FSocketConnected);
    if FConnect in FSocketConnected.State then
      Fail('Socket Not Closed');
  except
  on E : Exception do
    Fail('Disconnet returned error ' + e.Message);
  end;
end;

procedure TestTConnectedClient.TestCallBack;
var
  FApproved, FData, FBuf : TBytes;
  FUI : TBaseUI;
  BlockChain : TBlockChainCore;
  FMaxLenghtData, FTotalLenght, FLenghtData, FMinLenghtData : integer;
begin
  //Value
  FUI := TBaseUI.Create;
  FHandler.UI := FUI;
  FHandler.Net := FNetCore;
  FUI.Handler := FHandler;
  FData := nil;
  FBuf := nil;
  FApproved := [0,0,0,0,0,0,0,0,0];
  FMaxLenghtData := 65000;
  FMinLenghtData := 9;
  //Begin
  try
    BlockChain := TBlockChainCore.Create;
    FHandler.BlockChain := BlockChain;
    FNetCore.Start;
    CheckTrue(FNetCore.ServerStarted , 'Server is not started');
    if not (Assigned(FNetCore.Clients)) or (FNetCore.Clients[0] = nil) then
      Fail('No client connected');
    FData := FApproved;
    if not Assigned(FData) then
      Fail('Network package is nil');
    FLenghtData := Length(FData);
    setLength(Fbuf, SizeOf(integer));
    Move(FLenghtData, Fbuf[0], SizeOf(integer));
    FTotalLenght := FBuf[0] + FBuf[1] + FBuf[2] + FBuf[3];
    CheckEquals(FLenghtData, FTotalLenght, 'Network package created incorrectly');
    if (FLenghtData >= FMaxLenghtData) or (FLenghtData < FMinLenghtData) then
      Fail('Incorrectly Length package');
    if (FData[0] > 14) then   //(FData[3] <> 0)
      Fail('Incorrectly packet');
    FNetCore.SendPacket(FData);
    Sleep(5000);
    FNetCore.Stop;
    FUI.Free;
  except
  on E : Exception do
    begin
      FNetCore.Stop;
      Fail('CallBack returned error ' + e.Message);
    end;
  end;
end;

procedure TestTConnectedClient.TestStartReceive;
var
  FValue : TValue;
  FSocketNotNill : TSocket;
begin
  try
    FValue := TRttiContext.Create.GetType(TConnectedClient).GetField('Socket').GetValue(FConnectedClient);
    FValue.TryAsType(FSocketNotNill);
    if FSocketNotNill <> nil then
      FConnectedClient.StartReceive
    else
      Fail('Socket is nil');
  except
  on E : Exception do
    Fail('StartReceive returned error ' + e.Message);
  end;
end;

procedure TestTConnectedClient.TestSendMessage; //rework
var
  FData, FBuf: TBytes;
  FMinLenghtData, FMaxLenghtData, FTotalSize, FLenght : integer;
  FValue : TValue;
  FConnectedSocket : TSocket;
  FConnected : TSocketState;
begin
  //Value
  FData:= [4,3,0,0,0,0,0,0,0];
  FMaxLenghtData:= 65000;
  FMinLenghtData := 9;
  FConnected := TSocketState.Connected;
  FValue := TRttiContext.Create.GetType(TConnectedClient).GetField('Socket').GetValue(FConnectedClient);
  FValue.TryAsType(FConnectedSocket);
  try
  //Conditions
    if not Assigned(FConnectedSocket) then
      Fail('Socket is nil');
    if not (FConnected in FConnectedSocket.State) then
      Fail('Socket not connected');
    if not Assigned(FData) then
      Fail('Network package is nil');
    FLenght:= Length(FData);
    setLength(Fbuf, SizeOf(integer));
    Move(FLenght, Fbuf[0], SizeOf(integer));
    FTotalSize := FBuf[0] + FBuf[1] + FBuf[2] + FBuf[3];
    CheckEquals(FLenght, FTotalSize, 'Network package created incorrectly');
    if (FLenght >= FMaxLenghtData) or (FLenght < FMinLenghtData) then
      Fail('Incorrectly Length package');
    if (FData[0] > 14) then
      Fail('Incorrectly packet');
  //Begin
    FConnectedClient.SendMessage(FData);
  except
  on E: Exception do
    Fail('SendMessage returned error ' + e.Message);
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTConnectedClient.Suite);
end.

