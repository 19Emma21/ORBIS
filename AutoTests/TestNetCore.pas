unit TestNetCore;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework,
  Net.Core,
  System.Types,
  Net.ConnectedClient,
  System.SysUtils,
  System.Generics.Collections,
  Net.Server,
  App.IHandlerCore,
  App.HandlerCore,
  Net.Types,
  System.Net.Socket,
  System.Threading,
  Net.Client,
  System.RTTI,
  System.Math,
  App.Config,
  UI.Abstractions,
  System.Classes;

type

  // Test methods for class TNetCore

  TestTNetCore = class(TTestCase)
  protected
    FNodeHost : TArray<string>;
    FApprovedIp : TArray<string>;
  strict private
    FNetCore: TNetCore;
    FHandler : THandlerCore;
    FConnectedClient : TConnectedClient;
    FClient : TClient;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestStart;
    procedure TestStop;
    procedure TestSendPacket;
    procedure TestChecks;
    procedure TestDeleteConnectedClient;
    procedure TestGetFreeArraySell;
    procedure TestSendAll;
    procedure TestReferenceAfterDisconect(A, B : integer);
  end;

implementation

procedure TestTNetCore.TestChecks;
var
  FReturnValue : boolean;
  FRttiMethod : TRttiMethod;
  AIP : String;
  FList : TThreadList<string>;
  FValue : TValue;
begin
  //Value
  AIP := '127.0.0.1';
  try
  //Begin
    FRttiMethod := TRttiContext.Create.GetType(TNetCore).GetMethod('Checks');
    FReturnValue := FRttiMethod.Invoke(FNetCore,[AIp]).AsBoolean;
    if not Assigned(FApprovedIp) then
      fail('Approved IP list is nil');
    CheckTrue(FReturnValue , 'This ip address does not belong to ApprovedConnections');
    FValue:= TRttiContext.Create.GetType(TNetCore).GetField('Banlist').GetValue(FNetCore);
    FValue.TryAsType(Flist);
    if not FList.LockList.IndexOf(AIp) = -1 then
      Fail('Ip in ban list');
    FList.UnlockList;
  except
  on E : Exception do
    Fail('Checks returned error ' + e.Message);
  end;
end;

procedure TestTNetCore.TestDeleteConnectedClient;
var
  FRttiMethod : TRttiMethod;
  FSocket : TSocket;
  FCounter, FID, FStatus : Integer;
  FIP : String;
  FList : TThreadList<string>;
  FValue : TValue;
begin
  //Value
  FIP := '127.0.0.1';
  FID := 2;
//  FStatus := -1;    //Comment out this line for successful execution of the test
  FSocket:= TSocket.Create(TSocketType.TCP);
  FSocket.Connect('', '127.0.0.1', '', 30000);
  SetLength(FNetCore.ConnectedClients, 5);
  for FCounter := 0 to Length(FNetCore.ConnectedClients) - 1 do
    FNetCore.ConnectedClients[FCounter]:= Net.ConnectedClient.TConnectedClient.Create(Fsocket);
  //Begin
  try
    FRttiMethod:= TRttiContext.Create.GetType(TNetCore).GetMethod('DeleteConnectedClient');
    FRttiMethod.Invoke(FNetCore,[FID,Fstatus]);
    FID := 3;
    FStatus := 0;
    FRttiMethod.Invoke(FNetCore,[FID,Fstatus]);
//    Conditions
    CheckNull(FNetCore.ConnectedClients[2]);
    FValue:= TRttiContext.Create.GetType(TNetCore).GetField('Banlist').GetValue(FNetCore);
    FValue.TryAsType(Flist);
    if not FList.LockList.IndexOf(FIp) = -1 then
      Fail('Ip in ban list');
    FList.UnlockList;
  except
  on E : Exception do
    Fail('DeleteConnectedClient returned error ' + e.Message);
  end;
end;

procedure TestTNetCore.TestGetFreeArraySell;
var
  FRttiMethod : TRttiMethod;
  FSocket : TSocket;
  FCounter, FReturnValue, FCountFreeElem: Integer;
  FFreeElem : boolean;
begin
  //Value
  FFreeElem := false;
  FSocket:= TSocket.Create(TSocketType.TCP);
  FSocket.Connect('','127.0.0.1','',30000);
  SetLength(FNetCore.ConnectedClients, 8);
  for FCounter := 0 to Length(FNetCore.ConnectedClients) - 1 do
    FNetCore.ConnectedClients[FCounter]:= Net.ConnectedClient.TConnectedClient.Create(Fsocket);
  FNetCore.ConnectedClients[5] := nil;
  try
  //Begin
    FRttiMethod:= TRttiContext.Create.GetType(TNetCore).GetMethod('GetFreeArraySell');
    FReturnValue := FRttiMethod.Invoke(FNetCore,[]).AsInteger;
  //Conditions
    for FCounter := 0 to Length(FNetCore.ConnectedClients) - 1 do
      if (FNetCore.ConnectedClients[FCounter]) = nil then
       begin
        FFreeElem := true;
        FCountFreeElem := FCounter;
       end;
    CheckTrue(FFreeElem,'No one free element');
    CheckEquals(FReturnValue, FCountFreeElem, 'GetFreeArraySell didnt work');
  except
  on E : Exception do
    fail('GetFreeArraySell returned error ' + e.Message);
  end;
end;

procedure TestTNetCore.SetUp;
var
  FSocket : TSocket;
  Fconfig : TConfig;
begin
  FConfig := TConfig.Create;
  if not FConfig.DoConfigurate then
    Fail('Bad Config');
  FNodeHost := ['127.0.0.1'];
  FApprovedIp := ['127.0.0.1','192.168.0.2','192.168.1.25','192.168.66.6','10.10.10.57','10.158.69.42'];
  FHandler := THandlerCore.Create;
  FNetCore := TNetCore.Create(FHandler,FNodeHost,FApprovedIp);
  FSocket := TSocket.Create(TSocketType.TCP);
  FConnectedClient:= TConnectedClient.Create(FSocket);
  FConnectedClient.AfterDisconnect:= TestReferenceAfterDisconect;
  FClient:= TClient.Create(Fhandler);
end;

procedure TestTNetCore.TearDown;
begin
  FNetCore.Free;
  FNetCore := nil;
end;

procedure TestTNetCore.TestStart;
var
  FStatusServer : boolean;
  FValue : TValue;
  FTestConClient : TClient;
begin
  //Begin
  try
    if not Assigned(FNodeHost) then
      Fail('NodeHost is nil');
    if FNodeHost[0] = '' then
      Fail('NodeHost is empty');
    FNetCore.Start;
  //Conditions
    FStatusServer:= FNetCore.ServerStarted;
    CheckTrue(FStatusServer , 'Server is not running');
    FValue := TRttiContext.Create.GetType(TNetCore).GetField('MainClient').GetValue(FNetCore);
    FValue.TryAsType(FTestConClient);
    if not (Assigned(FTestConClient)) then
      Fail('ConnectedClient is not created');
  except
  on E : Exception do
    Fail('Start returned error ' + e.Message);
  end;
  //Finally
  FNetCore.Stop;
  FConnectedClient.Free;
  FClient.Free;
  FConnectedClient:= nil;
  FClient := nil;
end;

procedure TestTNetCore.TestStop;
var
  FSocket : TSocket;
  FServerActive, FNeedDestroy : Boolean;
  FValue : TValue;
begin
  //Value
  FNeedDestroy := false;
  FSocket:= TSocket.Create(TSocketType.TCP);
  FSocket.Connect('', '127.0.0.1', '', 30000);
  SetLength(FNetCore.ConnectedClients, 1);
  FNetCore.ConnectedClients[0]:= Net.ConnectedClient.TConnectedClient.Create(Fsocket);
  //Begin
  try
    if Length(FNetCore.ConnectedClients) = 0 then
      Fail('ConnectedClient is nil');
    FNetCore.Stop;
  //Conditions
    FValue:= TRttiContext.Create.GetType(TNetCore).GetField('NeedDestroySelf').GetValue(FNetCore);
    FNeedDestroy := FValue.AsBoolean;
    if FNeedDestroy = true then
      begin
        FNetCore := nil;
        exit;
      end;
    FServerActive := FNetCore.ServerStarted;
    CheckFalse(FServerActive, 'Server not stopped');
  except
  on E : Exception do
    Fail('Stop returned error ' + e.Message);
  end;
end;

procedure TestTNetCore.TestReferenceAfterDisconect(A, B: integer);
begin
//ForTest
end;

procedure TestTNetCore.TestSendAll;
var
  FData : TBytes;
  FConectSocket : TSocket;
begin
  try
  //Value
    FData:= [4,3,0,0,0,0,0,0,0];
    FConectSocket:= TSocket.Create(TSocketType.TCP);
    FConectSocket.Connect('', '127.0.0.1', '', 30000);
    SetLength(FNetCore.ConnectedClients, 1);
    FNetCore.ConnectedClients[0] := Net.ConnectedClient.TConnectedClient.Create(FConectSocket);
  //Conditions
    if not Assigned(FNetCore.ConnectedClients) then
      Fail('There are no connected clients');
    if not Assigned(FData) then //Add Check incorectly packet
      Fail('Data is nil');
  //Begin
    FNetCore.SendAll(FData);
  except
  on E : Exception do
    Fail('SendAll returned error ' + e.Message);
  end;
end;

procedure TestTNetCore.TestSendPacket; //Rework
var
  FData, FBuf: TBytes;
  FMinLenghtData, FMaxLenghtData, FTotalSize, FLenght : integer;
  FServer : TServer;
begin
//Value
  FServer := TServer.Create;
  FData:= [4,3,0,0,0,0,0,0,0];
  FMaxLenghtData:= 65000;
  FMinLenghtData := 9;
  try
//Conditions
    if not Assigned(FData) then
      Fail('Network package is nil');
    FLenght:= Length(FData);
    setLength(Fbuf, SizeOf(integer));
    Move(FLenght, Fbuf[0], SizeOf(integer));
    FTotalSize := FBuf[0] + FBuf[1] + FBuf[2] + FBuf[3];
    CheckEquals(FLenght, FTotalSize, 'Network package created incorrectly');
    if (FLenght >= FMaxLenghtData) or (FLenght < FMinLenghtData) then
      Fail('Incorrectly Length package');
    FServer.Start('127.0.0.1' , 30000);
//    FNetCore.SendPacket(FData); //MainClient = nil
    FClient.SendMessage(FData);
    FServer.Stop;
  except
  on E : Exception do
    begin
      Fail('SendPacket returned error ' + e.Message);
      FServer.Stop;
    end;
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTNetCore.Suite);
end.

