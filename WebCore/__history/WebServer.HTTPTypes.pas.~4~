unit WebServer.HTTPTypes;

interface

uses
  System.SysUtils,
  System.TypInfo,
  System.Hash,
  System.JSON,
  WebServer.SourceData;

const
  NL = #13#10;
  RHCount = 5;
  BASE_URI = '/api/';
  WALLET_ADDRESS_LENGTH = 40;

type

  TPosition = record
    Pos: Integer;
    Len: Integer;
  end;

  TPairs = class abstract
  private
    FData: String;
    procedure Reset;
    function GetPosition(const Name: string): TPosition; virtual; abstract;
  public
    constructor Create;
    function GetKeyValue(const Key: String): String; virtual; abstract;
    property Text: String read FData write FData;
  end;

  THeaders = class(TPairs)
  private
    function GetPosition(const Name: string): TPosition; override;
  public
    constructor Create;
    function GetKeyValue(const Key: String): String; override;
    function GetKeyPos(const Name: String): Integer;
    procedure AddHeader(const Key, Value: String);
  end;

  TParams = class(TPairs)
  private
    function GetPosition(const Name: string; Pos: Integer): TPosition;
  public
    constructor Create;
    function GetKeyValue(const Key: String; Pos: Integer): String;
    function GetKeyPos(const Name: String; Pos: Integer): Integer;
    function GetArgsCount: Integer;
  end;

  ReqType = (stGet, stPost, stUnknown);

  TRequest = class
  strict private
    StatusCode: Integer;
    ByteData: TBytes;
    StrData: String;
    Method: ReqType;
    URIPath: String;
    HTTPVer: String;
    FHeaders: THeaders;
    procedure Parse;
  public
    constructor Create(const AData: TBytes);
    procedure Reset;
    property Status: Integer read StatusCode;
    property ByteRequest: TBytes read ByteData write ByteData;
    property StrRequest: String read StrData write StrData;
    property RequestType: ReqType read Method;
    property Path: String read URIPath;
    property HTTPVersion: String read HTTPVer;
    destructor Destroy; override;
  end;

  TResponse = class
  strict private
    ByteData: TBytes;
    StrData: String;
    FHeaders: THeaders;
    FParams: TParams;
    procedure AddLine(Line: String);
    procedure AddWords(Words: String);
  public
    constructor Create(const Request: TRequest);
    procedure Reset;
    property ByteAnswer: TBytes read ByteData write ByteData;
    property StrAnswer: String read StrData write StrData;
    destructor Destroy; override;
  end;



implementation

uses
  WebServer;

const
  INCORRECT_REQUEST_CODE = -1;
  UNKNOWN_METHOD_CODE = -2;
  UNSUPPORTED_HTTP_VERSION_CODE = -3;
  NOT_FOUND_CODE = -4;

  ERR_BAD_REQUEST = '400 Bad Request';
  ERR_IM_A_TEAPOT = '418 I''m a Teapot';
  ERR_NOT_FOUND = '404 Not Found';
  REQUEST_OK = '200 OK';

{ TRequest }

constructor TRequest.Create(const AData: TBytes);
begin
  FHeaders := THeaders.Create();
  Reset;
  ByteData := AData;
  StrData := TEncoding.UTF8.GetString(AData);
  Parse;
end;

destructor TRequest.Destroy;
begin
  Reset;
  FHeaders.Free;
end;

procedure TRequest.Parse;
var
  RequestLine: String;
  SubStrPos: Integer;
begin
  SubStrPos := Pos(NL, StrRequest); // Ищем Request line
  if (SubStrPos = 0) then
  begin
    StatusCode := INCORRECT_REQUEST_CODE;
    exit;
  end;
  RequestLine := Copy(StrRequest, 0, SubStrPos - 1);
  StrRequest := Copy(StrRequest, SubStrPos + 2, Length(StrRequest) - SubStrPos);

  SubStrPos := Pos(NL + NL, StrRequest); // Выделяем заголовки
  if (SubStrPos = 0) then
  begin
    StatusCode := INCORRECT_REQUEST_CODE;
    exit;
  end;
  FHeaders.Text := Copy(StrRequest, 0, SubStrPos - 1);

  StrRequest := Copy(StrRequest, SubStrPos + 4, Length(StrRequest) - SubStrPos);
  // остаётся только тело запроса

  if RequestLine.StartsWith('GET') then // далее парсим Request line
    Method := stGet
  else if RequestLine.StartsWith('POST') then
    Method := stPost
  else
  begin
    StatusCode := UNKNOWN_METHOD_CODE;
    exit;
  end;

//  if (Method = stPost) then
//    if (StrRequest = '') then
//    begin
//      StatusCode := INCORRECT_REQUEST_CODE;
//      exit;
//    end;

  SubStrPos := Pos('HTTP/', RequestLine);
  if (SubStrPos = 0) then
  begin
    StatusCode := INCORRECT_REQUEST_CODE;
    exit;
  end;
  HTTPVer := Copy(RequestLine, SubStrPos + 5, 3);
  if (HTTPVer <> '1.1') then
  begin
    StatusCode := UNSUPPORTED_HTTP_VERSION_CODE;
    exit;
  end;

  case Method of
    stGet:
      begin
        URIPath := Trim(Copy(RequestLine, 5, SubStrPos - 5));
      end;

    stPost:
      begin
        URIPath := Trim(Copy(RequestLine, 6, SubStrPos - 6));
      end;
  end;

  if not URIPath.StartsWith(BASE_URI) then
  begin
    StatusCode := INCORRECT_REQUEST_CODE;
    exit;
  end;

  // URIPath := Copy(URIPath,Length(BASE_URI) + 1,Length(URIPath) - Length(BASE_URI));

end;

procedure TRequest.Reset;
begin
  StatusCode := 0;
  SetLength(ByteData, 0);
  StrData := '';
  Method := stUnknown;
  URIPath := '';
  HTTPVer := '';
  FHeaders.Reset;
  // RequestLine := '';
end;

{ THeaders }

procedure THeaders.AddHeader(const Key, Value: String);
begin
  FData := FData + Key + ': ' + Value + NL;
end;

function THeaders.GetKeyPos(const Name: String): Integer;
begin
  Result := (NL + FData.ToLower).IndexOf(NL + Name.ToLower + ':');
end;

constructor THeaders.Create;
begin
  inherited;
end;

function THeaders.GetPosition(const Name: string): TPosition;
var
  Pos, Len: Integer;
begin
  Pos := GetKeyPos(Name);

  Len := Pos;
  Pos := Pos + Length(Name) + 1;

  if Len <> -1 then
    Len := (FData.ToLower + NL).IndexOf(NL, Pos)
  else
    Pos := -1;

  Result.Pos := Pos;
  Result.Len := Len - Pos;
end;

function THeaders.GetKeyValue(const Key: String): String;
var
  P: TPosition;
begin
  P := GetPosition(Key);

  if P.Pos <> -1 then
    Result := Trim(Copy(FData, P.Pos + 1, P.Len))
  else
    Result := '';
end;

{ TPairs }

constructor TPairs.Create;
begin
  Reset;
end;

procedure TPairs.Reset;
begin
  Text := '';
end;

{ TResponse }

procedure TResponse.AddLine(Line: String);
begin
  Self.StrAnswer := Self.StrAnswer + NL + Line;
end;

procedure TResponse.AddWords(Words: String);
begin
  Self.StrAnswer := Self.StrAnswer + ' ' + Words;
end;

constructor TResponse.Create(const Request: TRequest);
var
  JSObj: TJSONObject;
  frstarg,scndarg,thrdarg,frtharg,fiftharg: String;
  pagenum,pagesize,ind: Integer;
  DblValue: Double;
begin
  FHeaders := THeaders.Create;
  FParams := TParams.Create;
  Reset;
  Self.StrAnswer := 'HTTP/1.1';
  case Request.Status of

    - 1, -2:
      AddWords(ERR_BAD_REQUEST);

    -3:
      AddWords(ERR_IM_A_TEAPOT);

    -4:
      AddWords(ERR_NOT_FOUND);

    0:
      AddWords(REQUEST_OK);

  end;

  Self.FHeaders.AddHeader('Content-Type', 'application/json');
  Self.AddLine(FHeaders.FData);

  if (Request.Status <> 0) then
    exit;

  try
    JSObj := TJSONObject.Create;
    try
      case Request.RequestType of
        stGet:
          begin

            if (Request.Path = '/api/crt/w') then
            begin
              FParams.FData := Copy(Request.Path,11,Length(Request.Path)).ToLower;
              if (FParams.FData <> '') then
                raise Exception.Create('no arguments expected');

              Randomize;
              JSObj.AddPair('pub_key', THashSHA1.GetHashString(FloatToStr(Now)));
              JSObj.AddPair('private_key', THashSHA1.GetHashString(FloatToStr(Now + Random(100))));
              JSObj.AddPair('address', THashSHA1.GetHashString(FloatToStr(Now - Random(100))));
            end
            else

            if (Request.Path.StartsWith('/api/balance/')) then
            begin
              FParams.FData := Copy(Request.Path,14,Length(Request.Path)).ToLower;
              if (FParams.GetArgsCount <> 1) then
                raise Exception.Create('bad arguments count');

              frstarg := FParams.GetKeyValue('wallet',1);
              if (frstarg = NL) then
                raise Exception.Create('argument ''wallet'' is not found');

              if (Length(frstarg) <> WALLET_ADDRESS_LENGTH) then
                raise Exception.Create('incorrect wallet address');

              Randomize;
              DblValue := (Random(999999999) + 1) * 0.00000001;
              JSObj.AddPair('wallet', frstarg);
              JSObj.AddPair('balance', FormatFloat('0.00000000',DblValue));
              JSObj.AddPair('success', TJSONBool.Create(True))
            end
            else

            if (Request.Path.StartsWith('/api/explorer/')) then
            begin
              FParams.FData := Copy(Request.Path,15,Length(Request.Path)).ToLower;
              if (FParams.GetArgsCount <> 4) then
                raise Exception.Create('bad arguments count');

              frstarg := FParams.GetKeyValue('name',1);
              if (frstarg = NL) then
                raise Exception.Create('argument ''name'' is not found');
              if not ((frstarg = 'accounts') or (frstarg = 'transactions'))then
                raise Exception.Create('incorrect name argument value');

              scndarg := FParams.GetKeyValue('pagesize',2);
              if (scndarg = NL) then
                raise Exception.Create('argument ''pagesize'' is not found');
              if not (TryStrToInt(scndarg,pagesize) and (pagesize > 0)) then
                raise Exception.Create('incorrect page size number');

              thrdarg := FParams.GetKeyValue('page',3);
              if (thrdarg = NL) then
                raise Exception.Create('argument ''page'' is not found');
              if not (TryStrToInt(thrdarg,pagenum) and (pagenum > 0))then
                raise Exception.Create('incorrect page number');

              frtharg := FParams.GetKeyValue('net',4);
              if (frtharg = NL) then
                raise Exception.Create('argument ''net'' is not found');
              if not (frtharg = 'main') then
                raise Exception.Create('incorrect net argument value');

              JSObj.Free;
              JSObj := FTestSource.GetData(frstarg,pagenum,pagesize);
            end
            else

            if (Request.Path.StartsWith('/api/address/')) then
            begin
              FParams.FData := Copy(Request.Path,14,Length(Request.Path)).ToLower;
              if (FParams.GetArgsCount <> 5) then
                raise Exception.Create('bad arguments count');

              frstarg := FParams.GetKeyValue('id',1);
              if (frstarg = NL) then
                raise Exception.Create('argument ''id'' is not found');
              if not (Length(frstarg) = 32)then
                raise Exception.Create('incorrect id argument value');

              scndarg := FParams.GetKeyValue('net',2);
              if (scndarg = NL) then
                raise Exception.Create('argument ''net'' is not found');
              if not (scndarg = 'main') then
                raise Exception.Create('incorrect net argument value');

              thrdarg := FParams.GetKeyValue('token',3);
              if (thrdarg = NL) then
                raise Exception.Create('argument ''token'' is not found');
              ind := GetEnumValue(TypeInfo(TTokenType),thrdarg);
              if (ind = -1) then
                raise Exception.Create('incorrect token argument value');

              frtharg := FParams.GetKeyValue('page',4);
              if (frtharg = NL) then
                raise Exception.Create('argument ''page'' is not found');
              if not (TryStrToInt(frtharg,pagenum) and (pagenum > 0))then
                raise Exception.Create('incorrect page number');

              fiftharg := FParams.GetKeyValue('pagesize',5);
              if (fiftharg = NL) then
                raise Exception.Create('argument ''pagesize'' is not found');
              if not (TryStrToInt(fiftharg,pagesize) and (pagesize > 0)) then
                raise Exception.Create('incorrect page size number');

              JSObj.Free;
              JSObj := FTestSource.GetAccData(frstarg,scndarg,thrdarg,pagenum,pagesize);
              if JSObj.Count = 0 then
                raise Exception.Create('wallet is not exists');
            end
            else

            if (Request.Path.StartsWith('/api/transaction_info/')) then
            begin
              FParams.FData := Copy(Request.Path,23,Length(Request.Path)).ToLower;
              if (FParams.GetArgsCount <> 2) then
                raise Exception.Create('bad arguments count');

              frstarg := FParams.GetKeyValue('id',1);
              if (frstarg = NL) then
                raise Exception.Create('argument ''id'' is not found');
              if not (Length(frstarg) = 40)then
                raise Exception.Create('incorrect id argument value');

              scndarg := FParams.GetKeyValue('net',2);
              if (scndarg = NL) then
                raise Exception.Create('argument ''net'' is not found');
              if not (scndarg = 'main') then
                raise Exception.Create('incorrect net argument value');

              JSObj.Free;
              JSObj := FTestSource.GetTransData(frstarg,scndarg);
              if JSObj.Count = 0 then
                raise Exception.Create('transaction is not exists');
            end

            else
              raise Exception.Create('bad request');
          end;

        stPost:
          begin
            if (Request.Path.StartsWith('/api/transaction/')) then
            begin
              FParams.FData := Copy(Request.Path,18,Length(Request.Path)).ToLower;
              if (FParams.GetArgsCount <> 3) then
                raise Exception.Create('bad arguments count');

              frstarg := FParams.GetKeyValue('from',1);
              if (frstarg = NL) then
                raise Exception.Create('argument ''from'' is not found');
              if (Length(frstarg) <> WALLET_ADDRESS_LENGTH) then
                raise Exception.Create('incorrect sender wallet address');

              scndarg := FParams.GetKeyValue('to',2);
              if (scndarg = NL) then
                raise Exception.Create('argument ''to'' is not found');
              if (Length(scndarg) <> WALLET_ADDRESS_LENGTH) then
                raise Exception.Create('incorrect receiver wallet address');

              if (frstarg = scndarg) then
                raise Exception.Create('identical wallets');

              thrdarg := FParams.GetKeyValue('amount',3);
              if (thrdarg = NL) then
                raise Exception.Create('argument ''amount'' is not found');

              if not (TryStrToFloat(thrdarg,DblValue) and (DblValue > 0)) then
                raise Exception.Create('incorrect amount');

              JSObj.AddPair('sender wallet address', frstarg);
              JSObj.AddPair('receiver wallet address', scndarg);
              JSObj.AddPair('amount', TJSONNumber.Create(DblValue));

              Randomize;
              if (Random(2) mod 2 = 0) then
                JSObj.AddPair('success', TJSONBool.Create(True))
              else
                raise Exception.Create('insufficient funds');
            end

            else
              raise Exception.Create('bad request');
          end;
        end;
      except
        on E: Exception do
        begin
          JSObj.AddPair('success', TJSONBool.Create(False));
          JSObj.AddPair('error', E.Message);
        end;
      end;
    finally
      Self.AddLine(JSObj.ToString);
      JSObj.Free;
    end;

  Self.ByteData := TEncoding.UTF8.GetBytes(Trim(Self.StrData));
end;

destructor TResponse.Destroy;
begin
  Reset;
  FHeaders.Free;
  FParams.Free;
end;

procedure TResponse.Reset;
begin
  SetLength(ByteData, 0);
  StrData := '';
  FHeaders.Reset;
  FParams.Reset;
end;

{ TParams }

constructor TParams.Create;
begin
  inherited;
end;

function TParams.GetKeyPos(const Name: String; Pos: Integer): Integer;
var
  i: Integer;
begin
  if (Pos = 1) then
  begin
    if (FData.ToLower.IndexOf('?' + Name.ToLower) = 0) then
      Result := 0
    else
      Result := -1;
  end else
  begin
    Result := 0;
    for i := 2 to Pos do
      Result := FData.ToLower.IndexOf('&',Result + 1);
    if (Copy(FData,Result + 2,Length(Name)) <> Name) then
      Result := -1;
  end;
end;

function TParams.GetPosition(const Name: string; Pos: Integer): TPosition;
var
  Ind, Len: Integer;
begin
  Ind := GetKeyPos(Name, Pos);

  Len := Ind;
  Ind := Ind + Length(Name) + 1;

  if Len <> -1 then
  begin
    Len := FData.ToLower.IndexOf('=', Ind);
    if Len <> Ind then
    begin
      Ind := -1;
      Len := -1;
    end else
    begin
      Len := FData.ToLower.IndexOf('&', Len);
      if (Len = -1) then
        Len := Length(FData.ToLower);
    end;
  end
  else
    Ind := -1;

  Result.Pos := Ind;
  Result.Len := Len - Ind;
end;

function TParams.GetArgsCount: Integer;
var
  Pos: Integer;
begin
  Result := 0;
  if Length(FData) = 0 then
    exit;

  Pos := 1;
  if not (FData[Pos] = '?') then
    exit
  else
    Inc(Result);

  while Pos < Length(FData) do
  begin
    if (FData[Pos] = '&') then
      Inc(Result);
    Inc(Pos);
  end;
end;

function TParams.GetKeyValue(const Key: String; Pos: Integer): String;
var
  P: TPosition;
begin
  P := GetPosition(Key, Pos);

  if P.Pos <> -1 then
    Result := Trim(Copy(FData, P.Pos + 2, P.Len - 1)).ToLower
  else
    Result := NL;
end;

end.
